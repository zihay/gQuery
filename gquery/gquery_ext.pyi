from collections.abc import Sequence
import enum
from typing import Annotated, overload

from numpy.typing import ArrayLike


class BVH:
    @overload
    def __init__(self, primitives: Sequence[LineSegment], max_prims_in_node: int = 10, split_method: BVHSplitMethod = BVHSplitMethod.SAH) -> None: ...

    @overload
    def __init__(self, vertices: Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]], indices: Sequence[Annotated[ArrayLike, dict(dtype='int32', shape=(2), order='C')]], max_prims_in_node: int = 10, split_method: BVHSplitMethod = BVHSplitMethod.SAH) -> None: ...

    @property
    def nodes(self) -> list[BVHNode]: ...

    @property
    def primitives(self) -> list[LineSegment]: ...

    @property
    def ordered_primitives(self) -> list[LineSegment]: ...

    def to_soa(self) -> SoABVH: ...

class BVHNode:
    def __init__(self) -> None: ...

    @property
    def box(self) -> BoundingBox: ...

    @property
    def n_primitives(self) -> int: ...

    @property
    def primitives_offset(self) -> int: ...

    @property
    def second_child_offset(self) -> int: ...

    @property
    def axis(self) -> int: ...

class BVHSplitMethod(enum.Enum):
    SAH = 0

class BoundingBox:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], arg1: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...

    @property
    def p_min(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...

    @p_min.setter
    def p_min(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...

    @property
    def p_max(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...

    @p_max.setter
    def p_max(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...

    def height(self) -> float: ...

    @overload
    def expand(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...

    @overload
    def expand(self, arg: BoundingBox, /) -> None: ...

    def extent(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...

    def centroid(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...

    def surface_area(self) -> float: ...

    def max_dimension(self) -> int: ...

    def offset(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...

class BoundingBox3D:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], arg1: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...

    @property
    def p_min(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...

    @p_min.setter
    def p_min(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...

    @property
    def p_max(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...

    @p_max.setter
    def p_max(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...

    def height(self) -> float: ...

    @overload
    def expand(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> None: ...

    @overload
    def expand(self, arg: BoundingBox3D, /) -> None: ...

    def extent(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...

    def centroid(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...

    def surface_area(self) -> float: ...

    def max_dimension(self) -> int: ...

    def offset(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')], /) -> Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]: ...

class LineSegment:
    def __init__(self) -> None: ...

    @property
    def a(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...

    @a.setter
    def a(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...

    @property
    def b(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]: ...

    @b.setter
    def b(self, arg: Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')], /) -> None: ...

SAH: BVHSplitMethod = BVHSplitMethod.SAH

class SoABVH:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg: BVH, /) -> None: ...

    @property
    def flat_tree(self) -> SoABVHNode: ...

    @flat_tree.setter
    def flat_tree(self, arg: SoABVHNode, /) -> None: ...

    @property
    def primitives(self) -> SoALineSegment: ...

    @primitives.setter
    def primitives(self, arg: SoALineSegment, /) -> None: ...

    @property
    def sorted_primitives(self) -> SoALineSegment: ...

    @sorted_primitives.setter
    def sorted_primitives(self, arg: SoALineSegment, /) -> None: ...

class SoABVHNode:
    def __init__(self) -> None: ...

    @property
    def box(self) -> SoABoundingBox: ...

    @box.setter
    def box(self, arg: SoABoundingBox, /) -> None: ...

    @property
    def reference_offset(self) -> list[int]: ...

    @reference_offset.setter
    def reference_offset(self, arg: Sequence[int], /) -> None: ...

    @property
    def n_references(self) -> list[int]: ...

    @n_references.setter
    def n_references(self, arg: Sequence[int], /) -> None: ...

    @property
    def second_child_offset(self) -> list[int]: ...

    @second_child_offset.setter
    def second_child_offset(self, arg: Sequence[int], /) -> None: ...

class SoABoundingBox:
    def __init__(self) -> None: ...

    @property
    def p_min(self) -> list[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]: ...

    @p_min.setter
    def p_min(self, arg: Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]], /) -> None: ...

    @property
    def p_max(self) -> list[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]: ...

    @p_max.setter
    def p_max(self, arg: Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]], /) -> None: ...

class SoABoundingBox3D:
    def __init__(self) -> None: ...

    @property
    def p_min(self) -> list[Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]]: ...

    @p_min.setter
    def p_min(self, arg: Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]], /) -> None: ...

    @property
    def p_max(self) -> list[Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]]: ...

    @p_max.setter
    def p_max(self, arg: Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(3), order='C')]], /) -> None: ...

class SoALineSegment:
    def __init__(self) -> None: ...

    @property
    def a(self) -> list[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]: ...

    @a.setter
    def a(self, arg: Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]], /) -> None: ...

    @property
    def b(self) -> list[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]: ...

    @b.setter
    def b(self, arg: Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]], /) -> None: ...
